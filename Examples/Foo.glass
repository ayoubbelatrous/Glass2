
#load "C.glass";
//#load "Memory.glass";

struct string {
	u8* data;
	u64 count;
};

struct SmallStruct {
	i32 x;
	i32 y;
	i32 z;
	i32 w;
};

struct BigStruct {
	SmallStruct x;
	SmallStruct y;
	SmallStruct z;
	SmallStruct w;
};

struct MassiveStruct {
	BigStruct x;
	BigStruct y;
	BigStruct z;
	BigStruct w;
};

struct InsaneStruct {
	MassiveStruct x;
	MassiveStruct y;
	MassiveStruct z;
	MassiveStruct w;
};

struct vec3
{
	f32 x;
	f32 y;
	f32 z;
};

struct Entity {
	i32 id;
	vec3 pos;
};

fn Take_Any(Any any) {

	Entity entity;

	Entity* data = cast(Entity*) any.data;
	Entity i = *data;
	*data = entity;
}

fn Take_Many(Entity e1, Entity e2, Entity e3, Entity e4, Entity e5) : Entity {
	return e1;
}

fn main2() : i32 {

	Entity entity;
	Take_Many(entity,entity,entity,entity,entity);

	return 0;
}

fn test_typeof() {
	i32 x = 0;
	type := *typeof(Type);
	printf("TypeName: %s\n", type.name);
}

fn array_test() : i32 {

	i32* array = xx malloc(sizeof(i32) * 10);

	array[0] = 10;
	array[1] = 20;

	printf("Pointer Array Test\n");

	i32 a_0 = array[0];
	printf("A0: %i\n", a_0);

	for 0..10 {
		printf("PtrArray[%i] :: %i\n", it_index, array[it_index]);
	}

	return 0;
}

fn main() : i32 {

	array_test();

	///printf("Hello World\n");
	return 0;
}