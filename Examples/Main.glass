#foreign fn printf !(u8 * format) : i32{}
#foreign fn sprintf !(u8 * format, u8 * buffer) : i32{}

#foreign fn fopen(u8* path, u8* mode) : u64* {}
#foreign fn fclose(u64* file) : void{}

#foreign fn malloc(u64 size) : void* {}
#foreign fn free(void* ptr) : void{}
#foreign fn strlen(u8* ptr) : u64{}

struct vec3
{
	f32 x;
	f32 y;
	f32 z;
};

struct mat4
{
	f32 x;	f32 y;	f32 z;	f32 w;
	f32 x1;	f32 y1;	f32 z1;	f32 w1;
	f32 x2;	f32 y2;	f32 z2;	f32 w2;
	f32 x3;	f32 y3;	f32 z3;	f32 w3;
};

fn add_vec3(vec3 lhs, vec3 rhs) : vec3
{
	vec3 result;
	result.x = lhs.x + rhs.x;
	result.y = lhs.y + rhs.y;
	result.z = lhs.z + rhs.z;
	return result;
}

fn sub_vec3(vec3 lhs, vec3 rhs) : vec3
{
	vec3 result;
	result.x = lhs.x - rhs.x;
	result.y = lhs.y - rhs.y;
	result.z = lhs.z - rhs.z;
	return result;
}

fn mul_vec3(vec3 lhs, vec3 rhs) : vec3
{
	vec3 result;
	result.x = lhs.x * rhs.x;
	result.y = lhs.y * rhs.y;
	result.z = lhs.z * rhs.z;
	return result;
}

fn div_vec3(vec3 lhs, vec3 rhs) : vec3
{
	vec3 result;
	result.x = lhs.x / rhs.x;
	result.y = lhs.y / rhs.y;
	result.z = lhs.z / rhs.z;
	return result;
}

fn transform_vec3_mat4(vec3 lhs, mat4 rhs) : vec3
{
	vec3 test = lhs;
	return test;
}

fn add_vec3_f32(vec3 lhs, float rhs) : vec3
{
	vec3 result;
	result.x = lhs.x + rhs;
	result.y = lhs.y + rhs;
	result.z = lhs.z + rhs;
	return result;
}

fn add_vec3_float(vec3 lhs, float rhs) : vec3
{
	vec3 result;
	result.x = lhs.x + rhs;
	result.y = lhs.y + rhs;
	result.z = lhs.z + rhs;
	return result;
}

#operator+ add_vec3;
#operator- sub_vec3;
#operator* mul_vec3;
#operator/ div_vec3;

#operator+ add_vec3_float;
#operator+ add_vec3_f32;

#operator* transform_vec3_mat4;

fn print_vec3(u8* name, vec3* vec)
{
	printf("%s = {x: %f, y: %f, z: %f}\n", name, vec.x, vec.y, vec.z);
}

fn _vec3(f32 x = 0, f32 y = 0, f32 z = 0) : vec3 {
	vec3 res; res.x = x; res.y = y; res.z = z;
	return res;
}

fn main() : i32
{
	vec3 a = _vec3(1, 1, 1);
	vec3 b = _vec3(1, 2, 1);

	vec3 x = a + 2.0;

	print_vec3("x", &x);
}