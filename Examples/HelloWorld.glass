#load "Renderer.glass";
#load "Texture.glass";
#load "Buffer.glass";
#load "Shader.glass";

#load "Math.glass";
#load "GL.glass";
#load "Print.glass";
#load "C.glass";
#load "File.glass";

struct GLFWwindow{};

#foreign fn glfwInit() : i32 {};
#foreign fn glfwCreateWindow(i32 w, i32 h, u8* name, void* share, void* monitor) : GLFWwindow* {};
#foreign fn glfwMakeContextCurrent(GLFWwindow* wnd) : void {};
#foreign fn glfwWindowShouldClose(GLFWwindow* wnd) : i32 {};

#foreign fn glfwPollEvents() : void {};
#foreign fn glfwSwapBuffers(GLFWwindow* wnd) : void {};

#foreign fn glfwSetWindowSizeCallback(GLFWwindow* window, (GLFWwindow*,i32,i32) callback) : (GLFWwindow*,i32,i32) {};
#foreign fn glfwSetFramebufferSizeCallback(GLFWwindow* window, (GLFWwindow*,i32,i32) callback) : (GLFWwindow*,i32,i32) {};

#foreign fn glfwSetKeyCallback(GLFWwindow* window, (GLFWwindow*,i32,i32,i32,i32) callback) : void* {};

#foreign fn glfwWindowHint(i32 hint, i32 value) : void {};

struct stbtt__buf
{
	void* data;
	i32 cursor;
	i32 size;
};

struct stbtt_fontinfo
{
	void* 	userdata;
	void* 	data;		// pointer to .ttf file
	i32 	fontstart;	// offset of start of font

	i32 numGlyphs;		// number of glyphs, needed for range checking

	// table locations as offset from start of .ttf
	i32 loca;
	i32 head;
	i32 glyf;
	i32 hhea;
	i32 hmtx;
	i32 kern;
	i32 gpos;
	i32 svg;
	/////////////////////////////

	i32 index_map;			// a cmap mapping for our chosen character encoding
	i32 indexToLocFormat;	// format needed to map from glyph index to glyph

	stbtt__buf cff;         // cff font data
	stbtt__buf charstrings; // the charstring index
	stbtt__buf gsubrs;      // global charstring subroutines index
	stbtt__buf subrs;       // private charstring subroutines index
	stbtt__buf fontdicts;   // array of font dicts
	stbtt__buf fdselect;    // map from glyph to fontdict
};

#foreign fn stbtt_GetFontOffsetForIndex(u8* data, i32 index): i32 {};
#foreign fn stbtt_InitFont(stbtt_fontinfo *info, u8* data, i32 offset) : i32 {};
#foreign fn stbtt_GetCodepointBitmap(stbtt_fontinfo *info, f32 scale_x, f32 scale_y, i32* codepoint, i32* width, i32* height, i32* xoff, i32* yoff) : u8* {};

struct stbtt_bakedchar
{
	// coordinates of bbox in bitmap
   u16 x0;
   u16 y0;
   u16 x1;
   u16 y1;
   ////////////////////////////////
   f32 xoff;
   f32 yoff;
   f32 xadvance;
};

#foreign fn stbtt_BakeFontBitmap(u8* data, i32 offset,	// font location (use offset=0 for plain .ttf)
f32 pixel_height,						// height of font in pixels
u8* pixels, i32 pw, i32 ph,				// bitmap to be filled in
i32 first_char, i32 num_chars,			// characters to bake
stbtt_bakedchar* chardata) : i32{};		// you allocate this, it's num_chars long

struct Application 	{
	Renderer2D 		r;

	bool 			running;

	i32 			WindowWidth;
	i32 			WindowHeight;
};
Application a;

//@Life
fn start() {
	printf("[INFO] :: Started\n");
	Renderer2D_init(&a.r);
}

fn update() {

	f32 width 		= cast(f32) a.WindowWidth;
	f32 height 		= cast(f32) a.WindowHeight;

	projection := Mat4();

	p := ortho(0.0, width, 0.0, height, -1.0, 1.0);
	tr := translation(Vec3(-width * 0.5, height*0.5, 0.0));

	projection = tr * p;

	Renderer2D_begin(&a.r, projection);

	f32 posx = 0.1;
	f32 posy = 0.1;

	Renderer2D_draw_quad(&a.r, Vec2(10.0, 10.0), Vec2(50.0, 50.0));
	Renderer2D_draw_quad(&a.r, Vec2(10.0, 150.0), Vec2(50.0, 100.0));

	Renderer2D_flush(&a.r);
}

//@BoilerPlate

fn Application_Init() : void {
	print("Inited Application\n");
}

fn resize_cb(GLFWwindow* w, i32 width, i32 height) {
	a.WindowWidth 	= width;
	a.WindowHeight	= height;
	glViewport(0, 0, width, height);
}

fn key_cb(GLFWwindow* window, i32 key, i32 scancode, i32 action, i32 mods) : void {
	if key == 256 {
		a.running = 0;
	}
}

i32 GLFW_CONTEXT_VERSION_MAJOR = 139266;
i32 GLFW_CONTEXT_VERSION_MINOR = 139267;

fn main() : i32 {

	a.running = 1;

	i32 init_result = glfwInit();

	Application_Init();

	if init_result == 0 {
		printf("Error Initilizaing GLFW\n");
	}

	a.WindowWidth 	= 700;
	a.WindowHeight	= 1000;

	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);

	GLFWwindow* window = glfwCreateWindow(a.WindowWidth, a.WindowHeight, "Editor", null, null);

	glfwSetKeyCallback(window, key_cb);
	glfwSetWindowSizeCallback(window, resize_cb);

	glfwMakeContextCurrent(window);
	InitGL();

	start();

	while a.running {

		glClearColor(0.1, 0.16, 0.15, 1.0);
		glClear(GL_COLOR_BUFFER_BIT);

		update();

		glfwPollEvents();
		glfwSwapBuffers(window);

		a.running = a.running and glfwWindowShouldClose(window) == 0;
	}

	return 0;
}