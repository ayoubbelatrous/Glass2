#load "Shader.glass";
#load "Texture.glass";
#load "Buffer.glass";
#load "Renderer.glass";

#load "GL.glass";
#load "File.glass";
#load "Print.glass";
#load "Math.glass";
#load "Memory.glass";
#load "C.glass";

#load "MSDF.glass";

struct GLFWwindow{};

#foreign fn glfwInit() : i32 {};
#foreign fn glfwCreateWindow(i32 w, i32 h, u8* name, void* share, void* monitor) : GLFWwindow* {};
#foreign fn glfwMakeContextCurrent(GLFWwindow* wnd) : void {};
#foreign fn glfwWindowShouldClose(GLFWwindow* wnd) : i32 {};

#foreign fn glfwPollEvents() : void {};
#foreign fn glfwSwapBuffers(GLFWwindow* wnd) : void {};

#foreign fn glfwSetWindowSizeCallback(GLFWwindow* window, (GLFWwindow*,i32,i32) callback) : (GLFWwindow*,i32,i32) {};
#foreign fn glfwSetFramebufferSizeCallback(GLFWwindow* window, (GLFWwindow*,i32,i32) callback) : (GLFWwindow*,i32,i32) {};

#foreign fn glfwSetKeyCallback(GLFWwindow* window, (GLFWwindow*,i32,i32,i32,i32) callback) : void* {};

#foreign fn glfwWindowHint(i32 hint, i32 value) : void {};

struct Application 	{
	Renderer2D 		r;

	bool 			running;

	i32 			WindowWidth;
	i32 			WindowHeight;
};
Application a;

struct Editor {
	u8[..] buffer;
};
Editor editor;


struct Atlas_Font {
	MSDF_Glyph[..] 		code_points;
	MSDF_FontMetrics 	metrics;

	Texture				atlas_texture;
};

fn Atlas_Font_GetGlyph(Atlas_Font* f, u32 code_point) : MSDF_Glyph* {

	glyph := cast(MSDF_Glyph*) null;

	for 0..f.code_points.count {

		glyph = &f.code_points[it_index];

		if glyph.code_point == code_point {
			it_index = f.code_points.count;
		}
	}

	return glyph;
}

MSDF_FreetypeHandle* msdf_ft_handle;

fn init_font() {

	//font_handle := MSDF_loadFont(msdf_ft_handle, "JetBrainsMono-SemiBold.ttf");
	font_handle := MSDF_loadFont(msdf_ft_handle, "JetBrainsMono-SemiBold.ttf");
	assert(font_handle, "Failed to open font");

	ascii_charset := MSDF_CreateASCIICharset();
	assert(ascii_charset, "Hello World");

	MSDF_FontGeometry font_geom;
	MSDF_Create_FontGeometry(&font_geom)
	MSDF_FontGeometry_loadCharset(&font_geom, font_handle, ascii_charset, 1.0);

	MSDF_FontGeometry_setGeometryEdgeColoring(&font_geom, 3.0, 0);

	MSDF_GlyphGeometry* glyphs;
	u64 glyph_count;
	MSDF_FontGeometry_Glyphs_GetDataAndCount(&font_geom, &glyphs, &glyph_count);

	MSDF_TightAtlasPackerSpec packer_spec;
	packer_spec.dimensionConstraint = MDSF_DimensionsConstraint.SQUARE;
	packer_spec.minScale 	= 32.0;
	packer_spec.scale 		= 40.0;
	packer_spec.pixelRange 	= 2.0;
	packer_spec.padding 	= 1;

	atlas_packer := MSDF_create_TightAtlasPacker(&packer_spec);
	pack_result := MSDF_TightAtlasPacker_Pack(atlas_packer, glyphs, glyph_count);

	i64 atlas_width;
	i64 atlas_height;
	MSDF_TightAtlasPacker_GetDimensions(atlas_packer, &atlas_width, &atlas_height);

	print("Atlas Size: %,%\n", atlas_width, atlas_height);

	font_metrics := MSDF_FontGeometry_GetFontMetrics(&font_geom);

	generator := cast(MSDF_4FLOAT_GEN*) null;
	generated_atlas := MSDF_Generate_MTSDF_4_FLOAT(atlas_width, atlas_height, 1, glyphs, glyph_count, &generator);

	MSDF_SaveImage_4_Byte("atlas.png", generator);

	glyph_metrics := NewArray(MSDF_Glyph, glyph_count * 2);
	MSDF_FontGeometry_Get_Glyphs(&font_geom, cast(MSDF_Glyph*) glyph_metrics.data);

	u8[..] pixels;
	pixels.data = cast(void*) generated_atlas;
	pixels.count = cast(u64) (atlas_width * atlas_height * 4 * 4);

	atlas_texture := Texture_Create(cast(u32) atlas_width, cast(u32) atlas_height, pixels, TextureFormat.RGBA8);

	Atlas_Font font;
	font.code_points = glyph_metrics;
	font.metrics = font_metrics;
	font.atlas_texture = atlas_texture;

	a.r.default_font = font;
}

vec2 texture_size;
f32 pixel_size;

fn start() {

	pixel_size = 16.0;
	texture_size = Vec2(1024.0, 1024.0);

	printf("[INFO] :: Started\n");

	msdf_ft_handle = MSDF_InitFreeType();
	assert(msdf_ft_handle, "[Error] :: Failed To Initialize FreeType\n");
	init_font();

	Renderer2D_init(&a.r);

	file := open_file("Examples/HelloWorld.glass",  File_Open_Mode.Read);
	editor.buffer = read_entire_file(file);
	close_file(file);
}

fn update() {

	f32 width 		= cast(f32) a.WindowWidth;
	f32 height 		= cast(f32) a.WindowHeight;

	projection := Mat4();

	p := ortho(0.0, width, 0.0, height, -1.0, 1.0);
	tr := translation(Vec3(-width * 0.5, height*0.5, 0.0));

	projection = tr * p;

	Renderer2D_begin(&a.r, projection);

	f32 posx = 0.1;
	f32 posy = 0.1;

	//Renderer2D_draw_quad(&a.r,Vec2(256.0,256.0), texture_size);

	Renderer2D_draw_text(&a.r, editor.buffer, pixel_size);

	Renderer2D_flush(&a.r);
}

//@BoilerPlate

fn Application_Init() : void {
	print("Inited Application\n");
}

fn resize_cb(GLFWwindow* w, i32 width, i32 height) {
	a.WindowWidth 	= width;
	a.WindowHeight	= height;
	glViewport(0, 0, width, height);
}

i32 GLFW_KEY_DOWN :: 264;
i32 GLFW_KEY_UP   :: 265;

fn key_cb(GLFWwindow* window, i32 key, i32 scancode, i32 action, i32 mods) : void {
	if key == 256 {
		a.running = 0;
	}

	if key == GLFW_KEY_UP {
		f32 zoom_factor = 0.8;
		texture_size = texture_size * zoom_factor;
		pixel_size = pixel_size * zoom_factor;
	}

	if key == GLFW_KEY_DOWN {
		f32 zoom_factor = 1.2;
		pixel_size = pixel_size * zoom_factor;
	}
}

i32 GLFW_CONTEXT_VERSION_MAJOR :: 139266;
i32 GLFW_CONTEXT_VERSION_MINOR :: 139267;

struct Kerning_Matrix {
	f32[..] data;
	u64 side_size;
};

fn main() : i32 {

	a.running = 1;

	i32 init_result = glfwInit();

	Application_Init();

	if init_result == 0 {
		printf("Error Initilizaing GLFW\n");
	}

	a.WindowWidth 	= 800;

	a.WindowHeight	= 1000;

	glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
	glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 5);

	GLFWwindow* window = glfwCreateWindow(a.WindowWidth, a.WindowHeight, "Editor", null, null);

	glfwSetKeyCallback(window, key_cb);
	glfwSetFramebufferSizeCallback(window, resize_cb);

	glfwMakeContextCurrent(window);
	InitGL();

	start();

	glEnable(GL_BLEND);
	glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

	while a.running {

		glClearColor(0.1, 0.1, 0.1, 1.0);
		glClear(GL_COLOR_BUFFER_BIT);

		update();

		glfwPollEvents();
		glfwSwapBuffers(window);

		a.running = a.running and glfwWindowShouldClose(window) == 0;
	}

	return 0;
}