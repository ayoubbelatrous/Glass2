//#foreign fn malloc(u64 size) : void* {};
//#foreign fn free(void* ptr) : void {};
//#foreign fn memcpy(void* destination, void* source, u64 num) : void *  {}

#foreign struct GLFWwindow{};

#foreign fn glfwInit() : i32 {};
#foreign fn glfwCreateWindow(i32 w, i32 h, u8* name, void* share, void* monitor) : GLFWwindow* {};
#foreign fn glfwMakeContextCurrent(GLFWwindow* wnd) : void {};
#foreign fn glfwWindowShouldClose(GLFWwindow* wnd) : i32 {};

#foreign fn glfwPollEvents() : void {};
#foreign fn glfwSwapBuffers(GLFWwindow* wnd) : void {};

#foreign fn glfwSetWindowSizeCallback(GLFWwindow* window, (GLFWwindow*,i32,i32) callback) : (GLFWwindow*,i32,i32) {};
#foreign fn glfwSetFramebufferSizeCallback(GLFWwindow* window, (GLFWwindow*,i32,i32) callback) : (GLFWwindow*,i32,i32) {};

//function_name(GLFWwindow* window, i32 key, i32 scancode, i32 action, i32 mods) : void
#foreign fn glfwSetKeyCallback(GLFWwindow* window, (GLFWwindow*,i32,i32,i32,i32) callback) : void* {};

struct Vertex {
	vec3 position;
};

fn _Vertex(vec3 pos) : Vertex {
	Vertex v;
	v.position = pos;
	return v;
}

struct Renderer2D
{
	void* 			quad_vertex_base;
	void* 			quad_vertex_pointer;
	u64 			vertex_count;

	VertexBuffer 	quad_vertex_buffer;
	VertexArray 	quad_vertex_array;

	Vertex[..]  	quad_vertices;

	mat4 			projection;
};

struct Application 	{
	Renderer2D 		r;

	bool 			running;

	i32 			WindowWidth;
	i32 			WindowHeight;
};
Application a;

u64 R2D_QUAD_COUNT = 5000;

fn Renderer2D_init(Renderer2D* r) {

	u64 quad_buffer_size = 6 * sizeof(Vertex);
	quad_buffer_size = quad_buffer_size * R2D_QUAD_COUNT;

	r.quad_vertex_base = malloc(quad_buffer_size);
	r.quad_vertex_pointer = r.quad_vertex_base;
	r.vertex_count = 0;

	quad_v_ly := BufferLayout_Create(Vertex, sizeof(Vertex));
	r.quad_vertex_buffer = VertexBuffer_Create(null, quad_buffer_size);
	r.quad_vertex_array = VertexArray_Create();

	VertexArray_AddVertexBuffer(&r.quad_vertex_array, &r.quad_vertex_buffer, &quad_v_ly);

	r.quad_vertices.data 	= malloc(6 * sizeof(Vertex));
	r.quad_vertices.count 	= 6;

	f32 nh = -0.5;

	r.quad_vertices[0] = _Vertex(Vec3(nh,	nh,0.0));
	r.quad_vertices[1] = _Vertex(Vec3(0.5,	nh,0.0));
	r.quad_vertices[2] = _Vertex(Vec3(nh,	0.5,0.0));

	r.quad_vertices[3] = _Vertex(Vec3(0.5,	nh,0.0));
	r.quad_vertices[4] = _Vertex(Vec3(nh,	0.5,0.0));
	r.quad_vertices[5] = _Vertex(Vec3(0.5,	0.5,0.0));
}

fn Renderer2D_flush(Renderer2D* r) {
	//Draw

	VertexArray_Bind(&r.quad_vertex_array);

	u64 buffer_size = r.vertex_count * sizeof(Vertex);

	//glNamedBufferSubData(
	//	r.quad_vertex_buffer.renderer_id,
	//	0,
	//	buffer_size,
	//	r.quad_vertex_base
	//);

	glBufferSubData(
		GL_ARRAY_BUFFER,
		0,
		buffer_size,
		r.quad_vertex_base
	);

	vtx_to_draw := cast(u32) r.vertex_count;
	//print("vtx_to_draw :: %\n", vtx_to_draw);

	glDrawArrays(GL_TRIANGLES, 0, vtx_to_draw);

	r.quad_vertex_pointer = r.quad_vertex_base;
	r.vertex_count = 0;

}

fn Renderer2D_draw_quad(Renderer2D* r, vec2 position, vec2 size) {

	u32 i = 0;

	Vertex* qvp = cast(Vertex*) r.quad_vertex_pointer;

	while i < 6 {

		v := r.quad_vertices[i];

		//@Fix currently the left type dominates inference switch to result of op if overloaded
		//p := r.projection * v.position;
		//vec2 p = r.projection * (v.position + position);

		mat4 transform = scaling(Vec3(size.x,size.y,0.0)) * translation(Vec3(position.x,-position.y,0.0));

		vec3 p = transform * v.position;
		p = r.projection * p;

		//print("P :: %\n", p);
		//print("Transform :: %\n", transform);

		v.position = p;

		*qvp = v;

		i = i + 1;
		qvp = &qvp[1];
	}

	quad_vertex_pointer = cast(void*) qvp;
	r.vertex_count = r.vertex_count + 6;
}

fn Renderer2D_begin(Renderer2D* r, mat4 p) {
	r.projection = p;
}

//@Life
fn start() {
	printf("[INFO] :: Started\n");
	Renderer2D_init(&a.r);
}

fn update() {

	f32 width 		= cast(f32) a.WindowWidth;
	f32 height 		= cast(f32) a.WindowHeight;

	mat4 projection = ortho(-width*0.5, width*0.5, -height*0.5, height*0.5,0.0 - 1.0, 1.0);
	projection = translation(Vec3(
		-width * 0.5,height * 0.5,0.0
	)) * projection;


	Renderer2D_begin(&a.r, projection);

	f32 posx = 0.1;
	f32 posy = 0.1;

	Renderer2D_draw_quad(&a.r, Vec2(50.0, 50.0), Vec2(100.0, 100.0));

	Renderer2D_flush(&a.r);
}

//@BoilerPlate

fn Application_Init() : void {
	print("Inited Application\n");
}

fn resize_cb(GLFWwindow* w, i32 width, i32 height) {
	a.WindowWidth 	= width;
	a.WindowHeight	= height;
	glViewport(0, 0, width, height);
}

fn key_cb(GLFWwindow* window, i32 key, i32 scancode, i32 action, i32 mods) : void {
	if key == 256 {
		a.running = 0;
	}
}

fn main() : i32 {

	int x = 10;
	i32 y = 31;

	i32 i = 0;

	a.running = 1;

	i32 init_result = glfwInit();

	Application_Init();

	if init_result == 0 {
		printf("Error Initilizaing GLFW\n");
	}

	a.WindowWidth 	= 700;
	a.WindowHeight	= 1000;

	GLFWwindow* window
		= glfwCreateWindow(a.WindowWidth, a.WindowHeight, "A Window", null, null);

	glfwSetKeyCallback(window, key_cb);
	glfwSetWindowSizeCallback(window, resize_cb);

	glfwMakeContextCurrent(window);
	InitGL();

	start();

	while a.running {

		glClearColor(0.1, 0.16, 0.15, 1.0);
		glClear(COLOR_BUF_BIT);

		update();

		glfwPollEvents();
		glfwSwapBuffers(window);

		a.running = a.running and glfwWindowShouldClose(window) == 0;
	}

	return 0;
}