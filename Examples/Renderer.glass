u64 R2D_QUAD_COUNT 			= 5000;
u64 R2D_VERTECIS_PER_QUAD 	= 4;

#foreign fn sqrt(f64 x) : f64 {};

fn Renderer2D_init(Renderer2D* r) {

	R2D_INDICES_COUNT := R2D_QUAD_COUNT * 6;

	u64 quad_buffer_size = R2D_VERTECIS_PER_QUAD * sizeof(Vertex);
	quad_buffer_size = quad_buffer_size * R2D_QUAD_COUNT;

	r.quad_vertex_base = malloc(quad_buffer_size);
	r.quad_vertex_pointer = r.quad_vertex_base;
	r.vertex_count = 0;

	quad_v_ly := BufferLayout_Create(Vertex, sizeof(Vertex));
	r.quad_vertex_buffer = VertexBuffer_Create(null, quad_buffer_size);
	r.quad_vertex_array = VertexArray_Create();

	VertexArray_AddVertexBuffer(&r.quad_vertex_array, &r.quad_vertex_buffer, &quad_v_ly);

	//@Vertices
	r.quad_vertices.data 	= malloc(R2D_VERTECIS_PER_QUAD * sizeof(vec4));
	r.quad_vertices.count 	= R2D_VERTECIS_PER_QUAD;

	r.quad_vertices[0] = Vec4(-0.5, 	-0.5, 	0.0, 	1.0);
	r.quad_vertices[1] = Vec4(0.5, 		-0.5, 	0.0, 	1.0);
	r.quad_vertices[2] = Vec4(0.5, 		0.5, 	0.0, 	1.0);
	r.quad_vertices[3] = Vec4(-0.5, 	0.5, 	0.0, 	1.0);

	//@UVs
	r.texture_coords.data 	= malloc(R2D_VERTECIS_PER_QUAD * sizeof(vec2));
	r.texture_coords.count 	= R2D_VERTECIS_PER_QUAD;

	r.texture_coords[0] = Vec2(0.0, 0.0);
	r.texture_coords[1] = Vec2(1.0, 0.0);
	r.texture_coords[2] = Vec2(1.0, 1.0);
	r.texture_coords[3] = Vec2(0.0, 1.0);

	r.shader = Shader_Create("Examples/quad.glsl");

	u32[..] quadIndices = NewArray(u32, R2D_INDICES_COUNT);

	u32 offset = 0;
	u32 i = 0;

	while i < cast(u32) R2D_INDICES_COUNT
	{
		quadIndices[(i + 0)] = offset + 0;
		quadIndices[(i + 1)] = offset + 1;
		quadIndices[(i + 2)] = offset + 2;
		quadIndices[(i + 3)] = offset + 2;
		quadIndices[(i + 4)] = offset + 3;
		quadIndices[(i + 5)] = offset + 0;

		offset = offset + 4;
		i = i + 6;
	}

	r.quad_index_buffer = IndexBuffer_Create(quadIndices);
}

fn Renderer2D_flush(Renderer2D* r) {
	//Draw

	IndexBuffer_Bind(&r.quad_index_buffer);
	VertexArray_Bind(&r.quad_vertex_array);

	u64 buffer_size = r.vertex_count * sizeof(Vertex);

	glBufferSubData(
		GL_ARRAY_BUFFER,
		0,
		buffer_size,
		r.quad_vertex_base
	);

	Shader_Bind(&r.shader);
	Shader_SetMat4(&r.shader, "u_ViewProjection", &r.projection);
	Shader_SetInt(&r.shader, "u_Tex", 0);

	glDrawElements(GL_TRIANGLES, cast(u32) r.index_count, GL_UNSIGNED_INT, null);

	r.quad_vertex_pointer = r.quad_vertex_base;

	r.vertex_count = 0;
	r.index_count = 0;
}

fn Renderer2D_draw_quad(Renderer2D* r, vec2 position, vec2 size, vec2[..] uvs) {

	Vertex* qvp = cast(Vertex*) r.quad_vertex_pointer;

	for 0..R2D_VERTECIS_PER_QUAD
	{
		t := translation(Vec3(position.x + size.x * 0.5, -position.y - size.y * 0.5, 0.0));
		s := scaling(Vec3(size.x, size.y, 1.0));

		ts := s * t;

		vec4 p = ts * r.quad_vertices[it_index];

		vertex := _Vertex(Vec3(p.x, p.y, p.z), uvs[it_index]);

		*qvp = vertex;
		qvp = &qvp[1];
	}

	r.quad_vertex_pointer = cast(void*) qvp;

	r.vertex_count = r.vertex_count + R2D_VERTECIS_PER_QUAD;
	r.index_count = r.index_count + 6;
}

fn Renderer2D_draw_quad(Renderer2D* r, vec2 position, vec2 size) {
	Renderer2D_draw_quad(r, position, size, r.texture_coords);
}

fn Renderer2D_draw_text(Renderer2D* r, u8[..] text) {
}

fn Renderer2D_begin(Renderer2D* r, mat4 p) {
	r.projection = p;
}

struct Vertex {
	vec3 position;
	vec2 texture_coords;
};

struct Renderer2DPass {
	void* 			vertex_base;
	void* 			vertex_pointer;

	u64 			vertex_count;
	u64 			index_count;

	VertexBuffer 	vertex_buffer;
	VertexArray 	vertex_array;
	IndexBuffer 	index_buffer;

	Type vertex_type;
};

struct Renderer2D
{
	void* 			quad_vertex_base;
	void* 			quad_vertex_pointer;
	u64 			vertex_count;
	u64 			index_count;

	VertexBuffer 	quad_vertex_buffer;
	VertexArray 	quad_vertex_array;
	IndexBuffer 	quad_index_buffer;

	vec4[..]  		quad_vertices;
	vec2[..]  		texture_coords;

	mat4 			projection;

	Shader 			shader;

	Texture[..]		textures;
};

fn _Vertex(vec3 pos, vec2 uv) : Vertex {
	Vertex v;
	v.position = pos;
	v.texture_coords = uv;
	return v;
}